#ifndef SYSTEM_HH
#define SYSTEM_HH

#include "spdlog/spdlog.h"
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wnull-dereference"
#include <regex>
#pragma GCC diagnostic pop
#include <string>
#include <vector>

#if __has_include(<filesystem>)
#include <filesystem>
namespace fs = std::filesystem;
#elif __has_include(<experimental/filesystem>)
#include <experimental/filesystem>
namespace fs = std::experimental::filesystem;
#else
#error "Could not find includes: <filesystem> or <experimental/filesystem>"
#endif

#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wtautological-compare"
#include "fmt/ranges.h"
#pragma GCC diagnostic pop
#include "fmt/std.h"

namespace achilles {

class ProcessGroup;

namespace SystemVariables {
    const std::string libPrefix = "@LIBPREFIX@";
    const std::string libSuffix = "@LIBSUFFIX@";
    const std::string pluginBase = libPrefix + "AchillesPlugin";
    const std::string pluginRegex = pluginBase + ".*\\" + libSuffix;
    const std::regex validPluginName(pluginRegex);
}

namespace PathVariables {
    const fs::path buildPath = "@BUILDPATH@";
    const fs::path installPath = "@INSTALLPATH@";
    const fs::path buildLibs = buildPath / "lib";
    const fs::path installLibs = installPath / "lib";
    const fs::path buildData = buildPath / "data";
    const fs::path buildFlux = buildPath / "flux";
    const fs::path installShare = installPath / "share/Achilles";
    const fs::path installFlux = installShare / "flux";
    const fs::path installData = installShare / "data";
    const fs::path installDefaults = installData / "default";
    const fs::path cacheDefault = ".achilles/cache";
}

namespace Filesystem {

std::vector<fs::path> AchillesPath();
std::string FindFile(const std::string &filename, const std::string &head);

class Cache {
  public:
    Cache() = default;
    Cache(const fs::path &path) : m_path{path} {}
    Cache(const Cache &) = default;
    Cache(Cache &&) = default;
    Cache &operator=(const Cache &) = default;
    Cache &operator=(Cache &&) = default;
    ~Cache() = default;

    const fs::path &Path() const { return m_path; }
    fs::path &Path() { return m_path; }

    bool FindCachedState(std::size_t);
    template <typename T> bool SaveState(const T &object) {
        auto cachePath = Path() / fmt::format("{:x}", std::hash<T>{}(object));
        if(fs::exists(cachePath))
            spdlog::warn("Cache: Overwriting existing cache for {}", object);
        fs::create_directories(cachePath);
        return object.Save(cachePath);
    }
    template <typename T> bool LoadState(T& object) {
        auto cachePath = Path() / fmt::format("{:x}", std::hash<T>{}(object));
        if(!fs::exists(cachePath)) {
            spdlog::debug("Cache: Not found for {}", object);
            return false;
        }
        fs::create_directories(cachePath);
        return object.Load(cachePath);
    }

  private:
    fs::path m_path{PathVariables::cacheDefault};
};

enum class FileType {
    any = -1,
    regular,
    directory,
    empty
};

std::vector<std::string> GetPluginPaths();

template<typename T>
bool is_type(const T &path, FileType type) {
    switch(type) {
        case FileType::any:
            return true;
        case FileType::regular:
            return fs::is_regular_file(path);
        case FileType::directory:
            return fs::is_directory(path);
        case FileType::empty:
            return fs::is_empty(path);
    }
    return false;
}

template<typename Func>
void RecurseDirectories(const fs::path &directory, Func f, FileType type = FileType::any) {
    for(const auto &file_path : fs::recursive_directory_iterator(directory)) {
        if(!is_type(file_path, type)) continue;
        f(file_path);
    }
}

bool CreateDirectories(const fs::path &path);

} // namespace Filesystem

} // namespace achilles

#endif
